package tasks

import "fmt"

type foo struct {
	field1 string
}

/*
Задание 2. Что выведет код? Найдите ошибку в коде?

Исходная программа выводит {1}
Метод String() для структуры foo, судя по-всему, предназначен для контроля формата по умолчанию для пользовательского типа.

(https://golang-blog.blogspot.com/2019/01/effective-go-print.html):
Если вам нужно вывести значения типа T, а также указатели на T, получатель для String должен иметь тип значения,
Использование в постановке задания 2 приемника-указателя, объясняется большей эффективностью и идиоматичностью для структурных типов.

Метод String() структуры foo вызывает Sprintf(), потому что процедуры печати полностью реентерабельны и могут быть
завернуты таким образом. Есть одна важная деталь, для понимания об этом подходе: не создавайте метод String, вызывая
Sprintf таким образом, что он будет повторяться в вашем String методе до бесконечности. Это может произойти, если
Sprintf вызов пытается распечатать получателя напрямую в виде строки, которая в свою очередь снова вызовет метод.
*/

// cтруктура foo имеет метод String(), в котором приемником-УКАЗАТЕЛЕМ является переменная f типа *foo.
func (f *foo) String() string {
	/* функция выводит значение поля field1 структуры foo
	   *foo - тип указателя, соответствующий структуре foo,
	    значит параметр f определен для обращения к памяти для структуры foo
		(функция требует передачи показателя к foo)
	*/
	return fmt.Sprintf("field1:%s", f.field1)
}

func Task2() {
	fmt.Println(foo{field1: "1"})

	// инициализация переменной 1:
	// bar1 - переменная типа указателя *foo, в bar1 можно присваивать ссылки на память для структур foo
	var bar1 *foo = &foo{field1: "1000"}
	fmt.Println(bar1) // вывод: &{1000}, но с учетом метода String()  - вывод: field1:1000

	// инициализация переменной 2:
	// создаем переменную bar2 (short description), содержащую адрес памяти, укаывающий на структуру foo
	bar2 := &foo{
		field1: "test value",
	}
	fmt.Println(bar2) // вывод: &{test value}, но с учетом метода String() - вывод: field1:test value

	// инициализация переменной 3:
	// создаем переменную bar3 как "экземпляр" структуры foo
	bar3 := foo{
		field1: "bar3 value",
	}
	fmt.Println(bar3) // вывод: {bar3 value} с учетом метода String()
}
