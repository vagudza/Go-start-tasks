package main3

import (
	"bytes"
	"fmt"
	"io"
)

const debug = false

/*
Задание 3. Найдите ошибку в коде

Переменная buf определена как тип указателя на bytes.Buffer, которая инициализируется как <nil>,
т.к. не указывает ни на какой адрес в памяти. Если debug == true, то под указатель buf
выделяется память, после чего выполняется метод записи в буфер и вывод байт данных из него.
В случае debug == false под буфер память не выделяется.

Ошибка в программе может быть:

1) функция f принимает аргумент типа io.Writer, но в нее передается переменная типа указателя *bytes.Buffer
2) если debug == false, то почему-то справедливо out != nil (true), хотя out и есть nil (тип указателя, не указывающий на область памяти)
3) с учетом п.2, происходит ошибка записи в буфер, который есть ссылка вникуда и под который не выделено памяти
*/

func main3() {
	// buf - переменная типа указателя *bytes.Buffer - <nil>
	var buf *bytes.Buffer
	if debug {
		// выделяем память, типа bytes.Buffer, а возвращаемое значение - указатель на вновь назначенное нулевое значение этого типа
		buf = new(bytes.Buffer) // new() - либо buf := &bytes.Buffer{} - buf уже не <nil>!!!
		//fmt.Println("-----", buf, "-----")
	}
	f(buf)
	if debug {
		fmt.Printf("--%s\n", buf)
	}
}

/*
 io.Writer представляет объект, в который вы можете записать поток байтов
*/
func f(out io.Writer) {
	// some actions
	// out - типа *bytes.Buffer, хотя функция f принимает параметр типа io.Writer!!!

	if out != nil {
		//fmt.Println("aa")
		// ошибка записи в буфер, который есть ссылка вникуда и под который не выделено памяти
		out.Write([]byte("done!")) // panic: runtime error: invalid memory address or nil pointer dereference
	}

	// пример сравнения с nil.
	var nowhere *int
	fmt.Printf("%s\n", nowhere) // *int=<nil>
	fmt.Printf("%s\n", out)     // <nil>

	fmt.Printf("--%s\n", nowhere != nil) // false
	fmt.Printf("--%s\n", out != nil)     // true ??
}

/*
	var b bytes.Buffer // Буфер не требует инициализации - https://pkg.go.dev/bytes#Buffer

	использование буферов в качестве временного рабочего пространства - как вариант оптимизации, это
	очень дешево - намного дешевле, чем распределение кучи - и, в отличие от типичного распределителя
	общего назначения, не предполагает конкуренции потоков.
	Переменные, выделенные стеком, в отличие от переменных, выделенных в куче, не несут никаких накладных расходов
	на сборщик мусора, потому что они уничтожаются, когда уничтожается остальная часть кадра стека - когда функция возвращается.

	Пакет io - предоставляет набор интерфейсов и вспомогательных функций для работы с потоками байтов.
*/
